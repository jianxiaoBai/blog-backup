---
title: linux 笔记
date: 2018-09-29 11:52:04
categories: [技术笔记]
tags: [linux, 笔记]
comments: false
---

## 系统结构目录

|目录路径|作用|
|--|--|
|/usr：| 用户的很多应用程序和文件都放在此目录下。|
|/usr/bin：|**系统用户** 使用的应用程序。|
|/usr/sbin：|**超级用户** 使用的比较高级的管理程序和系统守护程序。|
|/usr/src：|内核源代码默认的放置目录。|
|/home：|用户的主目录，该目录名一般是以用户的账号命名的。|
|/bin：|Binary 的缩写, 存放着最经常使用的终端命令。|
|/root：|该目录为系统管理员，也称作 **超级权限者** 的用户主目录。|
|/boot：|启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。|
|/etc：|存放所有的系统管理所需要的 **配置文件** 和子目录。|
|/dev ：|Device (设备)的缩写, 该目录下存放的是Linux的外部设备|
|/proc：|一个映射 **系统内存** 的虚拟目录，可以通过直接访问此目录获取系统信息。|
|/sbin：|存放 **系统管理员** 使用的系统管理程序。|
|/tmp：|存放一些临时文件的。|
|/var：|不断扩充或者 **经常被修改** 的文件会存放在此目录下，比如各种日志文件。|
|/media：|Linux 会把识别的设备挂载到这个目录下。|
|/lost+found：|当系统非法关机后，这里就存放了一些文件。|
|/lib：|存放系统最基本的动态连接共享库。几乎所有的应用程序都需要用到这些共享库。|
|/mnt：|该目录是为了让用户临时挂载其他文件系统的，可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。|
|/opt：| 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。|
|/selinux：| 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙。|
|/srv：| 该目录存放一些服务启动之后需要提取的数据。|
|/sys：| 该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。|

<!-- more -->

## 网卡与 IP 知识点

* **网卡** 是一个专门负责 `网络通讯` 的硬件设备
* **IP 地址** 是设置在网卡上的 `地址信息`, 是保证电脑之间正常通讯的重要设置
* **127.0.0.1** 被称为 `本地回环/环回地址`，一般用来测试本机网卡是否正常
* **ping** 一般用于检测当前计算机到目标计算机之间的网络 `是否通畅`

```html
<!-- 可以这样类比: -->
电脑   => 电话
网卡   => SIM 卡
IP    => 电话号码
ping  => 电话能不能打通
```

> tips：一台计算机中有可能会有一个 **物理网卡** 和 **多个虚拟网卡**，在 Linux 中物理网卡的名字通常以 `ensXX` 表示

## `SSH` 基础

在 Linux 中 SSH 是 **非常常用** 的工具，通过 **SSH 客户端** 我们可以连接到运行了 **SSH 服务器** 的远程机器上


* **SSH 客户端**是一种使用 `Secure Shell（SSH）` 协议连接到远程计算机的软件程序
* `SSH` 是目前较可靠，**专为远程登录会话和其他网络服务** 提供安全性的协议
    * 利用 `SSH 协议` 可以有效**防止远程管理过程中的信息泄露**
    * 通过 `SSH 协议` 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗
* `SSH` 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度


### 域名

* 由一串 **用点分隔** 的名字组成，例如：`www.itcast.cn`
* 是 **IP 地址** 的别名，方便用户记忆

### 端口号

* **IP 地址**：通过 **IP 地址** 找到网络上的 **计算机**
* **端口号**：通过 **端口号** 可以找到 **计算机上运行的应用程序**
  * **SSH 服务器** 的默认端口号是 `22`，如果是默认端口号，在连接的时候，可以省略

* 常见服务端口号列表：

| 服务       | 端口号 |
| ---------- | ------ |
| SSH 服务器 | 22     |
| Web 服务器 | 80     |
| HTTPS      | 443    |
| FTP 服务器 | 21     |

### 客户端的简单使用

```bash
ssh [-p port] user@remote
```

* `user` 是在远程机器上的用户名，如果不指定的话默认为当前用户
* `remote` 是远程机器的地址，可以是 **IP**／**域名**，或者是 **后面会提到的别名**
* `port` 是 **SSH Server 监听的端口**，如果不指定，就为默认值 `22`


> * 在工作中，SSH 服务器的端口号很有可能**不是 22**，如果遇到这种情况就需要使用 `-p` 选项，指定正确的端口号，否则无法正常连接到服务器


### SSH 高级

* 免密码登录
* 配置别名

> 提示：有关 SSH 配置信息都保存在用户家目录下的 `.ssh` 目录下

### 免密码登录

**步骤**

* 配置公钥
    * 执行 `ssh-keygen` 即可生成 SSH 钥匙，一路回车即可
* 上传公钥到服务器
    * 执行 `ssh-copy-id -p port user@remote`，可以让远程服务器记住我们的公钥

#### 示意图

![](https://ws2.sinaimg.cn/large/006tNbRwly1fvv3sko7yxj30nx0dkq46.jpg)

### 配置别名

每次都输入 `ssh -p port user@remote`，时间久了会觉得很麻烦，特别是当 `user`, `remote` 和 `port` 都得输入，而且还不好记忆

而 **配置别名** 可以让我们进一步偷懒，譬如用：`ssh mac` 来替代上面这么一长串，那么就在 `~/.ssh/config` 里面追加以下内容：

```
Host mac
    HostName ip地址
    User itheima
    Port 22
```

**保存之后，即可用 `ssh mac` 实现远程登录了，`scp` 同样可以使用**

## SCP 基础

* scp 就是 `secure copy`，是一个在 Linux 下用来进行 **远程拷贝文件** 的命令
* 它的**地址格式与 ssh 基本相同**，**需要注意的是**，在指定端口时用的是大写的 `-P` 而不是小写的

![](https://ws4.sinaimg.cn/large/006tNbRwly1fvv3rr5mnaj30nx06bdg1.jpg)

```bash
# 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py
# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径
scp -P port 01.py user@remote:Desktop/01.py

# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py
scp -P port user@remote:Desktop/01.py 01.py

# 加上 -r 选项可以传送文件夹
# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop
scp -r demo user@remote:Desktop

# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹
scp -r user@remote:Desktop demo
```

| 选项 | 含义                                                                                            |
| ---- | ----------------------------------------------------------------------------------------------- |
| -r   | 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 |
| -P   | 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口                                |

> * `scp` 这个终端命令只能在 `Linux` 或者 `UNIX` 系统下使用


## 用户权限相关命令

### 基本概念

* **用户** 是 Linux 系统工作中重要的一环，用户管理包括 **用户** 与 **组** 管理
* 在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都**必须拥有一个账号**，并且**对于不同的系统资源拥有不同的使用权限**
* 在 Linux 中，可以指定 **每一个用户** 针对 **不同的文件或者目录** 的 **不同权限**
* 对 **文件／目录** 的权限包括：

| 序号  | 权限  | 英文   | 缩写  | 数字代号 |
| :---: | :---: | :----: | :---: | :------: |
| 01    | 读    | read   | r     | 4        |
| 02    | 写    | write  | w     | 2        |
| 03    | 执行  | excute | x     | 1        |

### 组

* 为了方便用户管理，提出了 **组** 的概念，如下图所示

![001_组示意图](https://ws3.sinaimg.cn/large/006tNbRwly1fvv3vhlw8xj30a5064gll.jpg)

* 在实际应用中，可以预先针对 **组** 设置好权限，然后 **将不同的用户添加到对应的组中**，从而**不用依次为每一个用户设置权限**

### ls -l 扩展

* `ls -l` 可以查看文件夹下文件的详细信息，从左到右依次是：

    * **权限**，第 1 个字符如果是 `d` 表示目录
    * **硬链接数**，通俗地讲，就是有多少种方式，可以访问到当前目录／文件
    * **拥有者**，家目录下 文件／目录 的拥有者通常都是当前用户
    * **组**，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲
    * **大小**
    * **时间**
    * **名称**

![002_权限示意图](https://ws3.sinaimg.cn/large/006tNbRwly1fvv3wr254lj30hq041t8t.jpg)

### `chmod` 简单使用（重要）

* `chmod` 可以修改 **用户／组** 对 **文件／目录** 的权限
* 命令格式如下：

```bash
chmod +/-rwx 文件名|目录名
```

> 提示：以上方式会一次性修改 `拥有者` / `组` 权限，有关 `chmod` 的高级用法，后续会讲

### 超级用户

* Linux 系统中的 `root` 账号通常 **用于系统的维护和管理**，对操作系统的所有资源 **具有所有访问权限**
* 在大多数版本的 Linux 中，都不推荐 **直接使用 root 账号登录系统**
* 在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”

#### sudo

* `su` 是 `substitute user` 的缩写，表示 **使用另一个用户的身份**
* `sudo` 命令用来以其他身份来执行命令，预设的身份为 `root`
* 用户使用 `sudo` 时，必须先输入密码，之后有 **5 分钟的有效期限**，超过期限则必须重新输入密码

> 若其未经授权的用户企图使用 `sudo`，则会发出警告邮件给管理员

## **组管理** 终端命令

> 提示：**创建组** / **删除组** 的终端命令都需要通过 `sudo` 执行

| 命令                      | 作用                      |
| ------------------------- | ------------------------- |
| groupadd 组名             | 添加组                    |
| groupdel 组名             | 删除组                    |
| cat /etc/group            | 确认组信息                |
| chgrp -R 组名 文件/目录名 | 递归修改文件/目录的所属组 |

> 提示：
>
> * 组信息保存在 `/etc/group` 文件中
> * `/etc` 目录是专门用来保存 **系统配置信息** 的目录

![001_组示意图](https://ws3.sinaimg.cn/large/006tNbRwly1fvv3vhlw8xj30a5064gll.jpg)

* 在实际应用中，可以预先针对 **组** 设置好权限，然后 **将不同的用户添加到对应的组中**，从而**不用依次为每一个用户设置权限**

### 演练目标

1. 在 `python` 用户的桌面文件夹下创建 `Python学习` 目录
2. 新建 `dev` 组
3. 将 `Python学习` 目录的组修改为 `dev`

### **用户管理** 终端命令

> 提示：**创建用户** / **删除用户** / **修改其他用户密码** 的终端命令都需要通过 `sudo` 执行

### 创建用户／设置密码／删除用户

| 命令                               | 作用         | 说明                                                                                          |
| ---------------------------------- | ------------ | --------------------------------------------------------------------------------------------- |
| useradd -m -g 组 新建用户名        | 添加新用户   | <ul><li>-m 自动建立用户家目录</li><li>-g 指定用户所在的组，否则会建立一个和同名的组</li></ul> |
| passwd 用户名                      | 设置用户密码 | 如果是普通用户，直接用 passwd 可以修改自己的账户密码                                          |
| userdel -r 用户名                  | 删除用户     | -r 选项会自动删除用户家目录                                                                   |
| cat /etc/passwd &#124; grep 用户名 | 确认用户信息 | 新建用户后，用户信息会保存在 /etc/passwd 文件中                                               |

> * 创建用户时，如果忘记添加 `-m` 选项指定新用户的家目录 —— 最简单的方法就是**删除用户，重新创建**
> * 创建用户时，默认会创建一个和**用户名**同名的**组名**
> * 用户信息保存在 `/etc/passwd` 文件中

### 查看用户信息

| 序号 | 命令        | 作用                       |
| ---- | ----------- | -------------------------- |
| 01   | id [用户名] | 查看用户 UID 和 GID 信息   |
| 02   | who         | 查看当前所有登录的用户列表 |
| 03   | whoami      | 查看当前登录用户的账户名   |

#### passwd 文件

`/etc/passwd` 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是

1. 用户名
2. 密码（x，表示加密的密码）
3. UID（用户标识）
4. GID（组标识）
5. 用户全名或本地帐号
6. 家目录
7. 登录使用的 Shell，就是登录之后，使用的终端命令，`ubuntu` 默认是 `dash`

#### usermod

* `usermod` 可以用来设置 **用户** 的 **主组** ／ **附加组** 和 **登录 Shell**，命令格式如下：
* **主组**：通常在新建用户时指定，在 `etc/passwd` 的第 4 列 **GID 对应的组**
* **附加组**：在 `etc/group` 中最后一列表示该组的用户列表，用于指定 **用户的附加权限**

> 提示：设置了用户的附加组之后，需要重新登录才能生效！

```bash
# 修改用户的主组（passwd 中的 GID）
usermod -g 组 用户名

# 修改用户的附加组
usermod -G 组 用户名

# 修改用户登录 Shell
usermod -s /bin/bash 用户名
```

> 注意：默认使用 `useradd` 添加的用户是没有权限使用 `sudo` 以 `root` 身份执行命令的，可以使用以下命令，将用户添加到 `sudo` 附加组中

```bash
usermod -G sudo 用户名
```
#### which（重要）

> 提示
>
> * `/etc/passwd` 是用于保存用户信息的文件
> * `/usr/bin/passwd` 是用于修改用户密码的程序

* `which` 命令可以查看执行命令所在位置，例如：

```bash
which ls

# 输出
# /bin/ls

which useradd

# 输出
# /usr/sbin/useradd
```

##### `bin` 和 `sbin`

* 在 `Linux` 中，绝大多数可执行文件都是保存在 `/bin`、`/sbin`、`/usr/bin`、`/usr/sbin`
* `/bin`（`binary`）是二进制执行文件目录，主要用于具体应用
* `/sbin`（`system binary`）是系统管理员专用的二进制代码存放目录，主要用于系统管理
* `/usr/bin`（`user commands for applications`）后期安装的一些软件
* `/usr/sbin`（`super user commands for applications`）超级用户的一些管理程序

> 提示：
>
> * `cd` 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 `which` 无法找到 `cd` 命令的位置

#### 切换用户

| 序号 | 命令        | 作用                   | 说明                                     |
| ---- | ----------- | ---------------------- | ---------------------------------------- |
| 01   | su - 用户名 | 切换用户，并且切换目录 | - 可以切换到用户家目录，否则保持位置不变 |
| 02   | exit        | 退出当前登录账户       |                                          |

* `su` 不接用户名，可以切换到 `root`，但是不推荐使用，因为不安全
* `exit` 示意图如下：

![003_su和exit示意图](https://ws1.sinaimg.cn/large/006tNbRwly1fvv3xt2jqfj30dy076q33.jpg)

### 修改文件权限

| 命令  | 作用       |
| ----- | ---------- |
| chown | 修改拥有者 |
| chgrp | 修改组     |
| chmod | 修改权限   |

* 命令格式如下：

```bash
# 修改文件|目录的拥有者
chown 用户名 文件名|目录名

# 递归修改文件|目录的组
chgrp -R 组名 文件名|目录名

# 递归修改文件权限
chmod -R 755 文件名|目录名
```

* `chmod` 在设置权限时，可以简单地使用三个数字分别对应 **拥有者** ／ **组** 和 **其他** 用户的权限

```bash
# 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他
chmod +/-rwx 文件名|目录名
```

![004_文件权限示意图](https://ws3.sinaimg.cn/large/006tNbRwly1fvv3y1jzq8j30b60etdg5.jpg)

* 常见数字组合有（`u`表示用户／`g`表示组／`o`表示其他）：
    * `777` ===> `u=rwx,g=rwx,o=rwx`
    * `755` ===> `u=rwx,g=rx,o=rx`
    * `644` ===> `u=rw,g=r,o=r`

#### `chmod` 演练目标

1. 将 `01.py` 的权限修改为 `u=rwx,g=rx,o=r`
2. 将 `123.txt` 的权限修改为 `u=rw,g=r,o=-`
3. 将 `test` 目录以及目录下的 **所有** 文件权限修改为 `u=rwx,g=rwx,o=rx`


## 系统信息相关命令

### 时间和日期

| 命令 | 作用                                             |
| ---- | ------------------------------------------------ |
| date | 查看系统时间                                     |
| cal  | `calendar` 查看日历，`-y` 选项可以查看一年的日历 |

### 磁盘信息

| 命令           | 作用                              |
| -------------- | --------------------------------- |
| df -h          | `disk free` 显示磁盘剩余空间      |
| du -h [目录名] | `disk usage` 显示目录下的文件大小 |

* 选项说明

| 参数 | 含义                       |
| ---- | -------------------------- |
| -h   | 以人性化的方式显示文件大小 |

### 进程信息

* 所谓 **进程**，通俗地说就是 **当前正在执行的一个程序**

| 命令               | 作用                                  |
| ------------------ | ------------------------------------- |
| ps aux             | `process status` 查看进程的详细状况   |
| top                | 动态显示运行中的进程并且排序          |
| kill [-9] 进程代号 | 终止指定代号的进程，`-9` 表示强行终止 |

> `ps` 默认只会显示当前用户通过终端启动的应用程序

* `ps` 选项说明

| 选项 | 含义                                     |
| ---- | ---------------------------------------- |
| a    | 显示终端上的所有进程，包括其他用户的进程 |
| u    | 显示进程的详细状态                       |
| x    | 显示没有控制终端的进程                   |

> 提示：使用 `kill` 命令时，最好只终止由当前用户开启的进程，而不要终止 `root` 身份开启的进程，否则可能导致系统崩溃

>
> * 要退出 `top` 可以直接输入 `q`

## 其他命令

### 查找文件

* `find` 命令功能非常强大，通常用来在 **特定的目录下** **搜索** 符合条件的文件

| 命令                     | 作用                                            |
| ------------------------ | ----------------------------------------------- |
| find [路径] -name "*.py" | 查找指定路径下扩展名是 `.py` 的文件，包括子目录 |

* 如果省略路径，表示在当前文件夹下查找
* 之前学习的通配符，在使用 `find` 命令时同时可用
* 有关 `find` 的高级使用，在就业班会讲

#### 演练目标

* 1. 搜索桌面目录下，文件名包含 `1` 的文件

```bash
find -name "*1*"
```

* 2. 搜索桌面目录下，所有以 `.txt` 为扩展名的文件

```bash
find -name "*.txt"
```

* 3. 搜索桌面目录下，以数字 `1` 开头的文件

```bash
find -name "1*"
```

### 02. 软链接

| 序号 | 命令                          | 作用                                                                |
| ---- | ----------------------------- | ------------------------------------------------------------------- |
| 01   | ln -s 被链接的源文件 链接文件 | 建立文件的软链接，用通俗的方式讲**类似于** Windows 下的**快捷方式** |

* 注意：
* 1. 没有 `-s` 选项建立的是一个 **硬链接文件**
    * 两个文件占用相同大小的硬盘空间，**工作中几乎不会建立文件的硬链接**
* 2. **源文件要使用绝对路径**，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用

### 演练目标

* 1. 将桌面目录下的 `01.py` **移动**到 `demo/b/c` 目录下
* 2. 在桌面目录下新建 `01.py` 的 **软链接** `FirstPython`
    * 分别使用 **相对路径** 和 **绝对路径** 建立 `FirstPython` 的软链接
* 3. 将 `FirstPython` **移动**到 `demo` 目录下，对比使用 **相对路径** 和 **绝对路径** 的区别

### 硬链接简介（知道）

* 在使用 `ln` 创建链接时，如果没有 `-s` 选项，会创建一个 **硬链接**，而不是软链接

#### 硬链接演练

* 1. 在 `~/Desktop/demo` 目录下建立 `~/Desktop/demo/b/c/01.py` 的硬链接 `01_hard`
* 2. 使用 `ls -l` 查看文件的**硬链接数**（硬链接——有多少种方式可以访问文件或者目录）
* 3. 删除 `~/Desktop/demo/b/c/01.py`，并且使用 `tree` 来确认 `demo` 目录下的三个链接文件

#### 文件软硬链接的示意图

![001_文件软硬链接示意图](https://ws1.sinaimg.cn/large/006tNbRwly1fvv41w2wvtj30vl0agwf4.jpg)

> 在 Linux 中，**文件名** 和 **文件的数据** 是分开存储的

* 提示：
    * 在 Linux 中，只有文件的 `硬链接数 == 0` 才会被删除
    * 使用 `ls -l` 可以查看一个文件的硬链接的数量
    * 在日常工作中，几乎不会建立文件的硬链接，知道即可

## 打包压缩

* **打包压缩** 是日常工作中备份文件的一种方式
* 在不同操作系统中，常用的打包压缩方式是不同的
    * `Windows` 常用 `rar`
    * `Mac` 常用 `zip`
    * `Linux` 常用 `tar.gz`

### 打包 ／ 解包

* `tar` 是 Linux 中最常用的 **备份**工具，此命令可以 **把一系列文件** 打包到 **一个大文件中**，也可以把一个 **打包的大文件恢复成一系列文件**
* `tar` 的命令格式如下：

```bash
# 打包文件
tar -cvf 打包文件.tar 被打包的文件／路径...

# 解包文件
tar -xvf 打包文件.tar
```

* `tar` 选项说明

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| c    | 生成档案文件，创建打包文件                                   |
| x    | 解开档案文件                                                 |
| v    | 列出归档解档的详细过程，显示进度                             |
| f    | 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后 |

> 注意：`f` 选项必须放在最后，其他选项顺序可以随意

#### 打包解包演练

1. 删除桌面下的所有内容
2. 在桌面下新建三个空白文件 `01.py`、`02.py`、`03.py`
3. 将这三个文件打一个 `py.tar` 的包
4. 新建 `tar` 目录，并且将 `py.tar` 移动到 `tar` 目录下
5. 解包 `py.tar`

###  压缩／解压缩

#### `gzip`

* `tar` 与 `gzip` 命令结合可以使用实现文件 **打包和压缩**
    * `tar` 只负责打包文件，但不压缩
    * 用 `gzip` 压缩 `tar` 打包后的文件，其扩展名一般用 `xxx.tar.gz`

> 在 `Linux` 中，最常见的压缩文件格式就是 `xxx.tar.gz`

* 在 `tar` 命令中有一个选项 **-z** 可以调用 `gzip`，从而可以方便的实现压缩和解压缩的功能

* 命令格式如下：

```bash
# 压缩文件
tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...

# 解压缩文件
tar -zxvf 打包文件.tar.gz

# 解压缩到指定路径
tar -zxvf 打包文件.tar.gz -C 目标路径
```

| 选项 | 含义                                           |
| ---- | ---------------------------------------------- |
| -C   | 解压缩到指定目录，注意：要解压缩的目录必须存在 |

#### `bzip2(two)`

* `tar` 与 `bzip2` 命令结合可以使用实现文件 **打包和压缩**（用法和 `gzip` 一样）
    * `tar` 只负责打包文件，但不压缩，
    * 用 `bzip2` 压缩 `tar` 打包后的文件，其扩展名一般用 `xxx.tar.bz2`

* 在 `tar` 命令中有一个选项 **-j** 可以调用 `bzip2`，从而可以方便的实现压缩和解压缩的功能

* 命令格式如下：

```bash
# 压缩文件
tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...

# 解压缩文件
tar -jxvf 打包文件.tar.bz2
```

## 软件安装

## 通过 apt 安装／卸载软件

* apt 是 `Advanced Packaging Tool`，是 Linux 下的一款安装包管理工具
* 可以在终端中方便的 **安装**／**卸载**／**更新软件包**

```bash
# 1. 安装软件
$ sudo apt install 软件包

# 2. 卸载软件
$ sudo apt remove 软件名

# 3. 更新已安装的包
$ sudo apt upgrade
```

### 安装演练

```bash
# 一个小火车提示
$ sudo apt install sl

# 一个比较漂亮的查看当前进程排名的软件
$ sudo apt install htop
```

压缩解压 tar
如果要在服务器之间发送大量数据，肯定少不了压缩和解压这两步，但是 tar 这个命令的参数之多，让我很绝望，于是我发明了一个简单的记忆方法。

使用 tar 命令只要记得参数是『必选+自选+f』即可，我们先来看看『必选！五选一』:
```
-c 意为 create，表示创建压缩包
-x 意为 extract，表示解压
-t 表示查看内容
-r 给压缩包追加文件
-u 意为 update，更新压缩包中的文件
```

注意了，上面是一定要五选一的，不能一个都不选，也不能同时选俩。但是自选的部分就可以按照需要挑选了，比如：

```
-z 使用 gzip 属性
-j 使用 bz2 属性
-Z 使用 compress 属性
-v 意为 verbose，显示详细的操作过程
-O 将文件输出到标准输出
```

然后最后一个一定要是 f 后面跟压缩包名（无论是要解压还是要压缩，都是指压缩包的名字）。接下来我们看看具体实例，就很容易理解具体的用法了。

```
# 假设我们有很多 .md 文件需要打包，那么可以使用
tar -cf posts.tar *.md # c 是创建压缩包，也就是压缩，然后是 f，给出压缩包名，最后是要压缩的文件
# 然后我们发现还有一些 .txt 文件也需要打包进去，那么可以使用
tar -rf posts.tar *.txt # r 是追加文件
# 然后我们发现 hello.md 弄错了，修正后需要更新到压缩包中，可以使用
tar -uf post.tar hello.md # u 是更新
# 压缩好了，我们来看看压缩包的内容，可以使用
tar -tf posts.tar # t 是列出文件内容
# 把压缩包发送到其他位置之后，需要解压，可以使用
tar -xf posts.tar # x 是解压
加入自选参数后的用法（要不要加 v 可以看个人喜好）
```

## tar.gz 相关

```
tar -czf posts.tar.gz *.md # 压缩
tar -xzf posts.tar.gz # 解压
```

## tar.bz2 相关

```
tar -cjf posts.tar.bz2 *.md # 压缩
tar -xjf posts.tar.bz2 # 解压
```

## tar.Z 相关

```
tar -cZf posts.tar.Z *.md # 压缩
tar -xZf posts.tar.Z # 解压
```
总结一波，遇到不同类型的文件，请用不同的套路来应对：

* .tar -> tar -xf
* .tar.gz -> tar -xzf
* .tar.bz2 -> tar -xjf
* .tar.Z -> tar -xZf
* .gz -> gzip -d
* .rar -> unrar e
* .zip -> unzip

空间占用 du
很多时候磁盘被写满了是各种奇怪错误的源头，所以如何快速找到问题所在就很重要了，

```
# 显示当前文件下 Top 10 空间占用的文件/目录，
# s 表示不显示每个子目录或文件的大小
# h 表示用更加自然的方式显示（比如 K/M/G 这样）
du -sh * | sort -nr | head
```

系统状态 top
了解系统状态一般少不了 top 命令，虽然基本上不需要做任何操作，但是还是有一些可以自定义的内容的，比如
```
# 查看某用户的进程
top -u wdxtub
# 进入系统状态显示后，具体值代表的意思是
# PR    进程优先级，越小优先级越高
# VIRT  占用的虚拟内存
# RES   占用的物理内存
# SHR   占用的共享内存
# S     进程状态（S - 休眠，R - 正在运行，Z - 僵死状态，N - 优先级为负数）
# TIME+ 进程启动后占用的总 CPU 时间
# 可以按照不同的指标排序显示，按对应键即可
# P 按照 CPU 使用率排序
# T 按照 MITE+ 排序
# M 按内存使用占比排序
```

其他查看进程相关信息的命令有

```
# 查看进程内存分布
pmap -d 12345 # 12345 是进程号
# 按照内存排序，这里的 grep 可以过滤特定的用户
ps -e -o 'pid,comm,srgs,pcpu,rsz,vsz,stime,user,uid' | grep wdxtub | sort nrk5
```

查找 find
在命令行界面中进行查找是每个需要在服务器上执行操作的同学都必备的技能，这里用实例来说明常见的实用用法

```
# 找出七天前的文件
find / -type f -mtime +7 -print
# / 表示从根目录中查找
# -type f 表示找出系统普通文件，不包含目录
# -mtime +n 表示寻找 n 天前的数据
# -print 打印文件名称
# 找出并删除七天前的文件
find /temp/ -type f -mtime +7 -print -exec rm -f {} \;
# -exec 表示后面执行系统命令
# {} 只有该符号能跟在命令你后面
# \; 结束符号
find /temp/ -type f -mtime +7 -print | xargs rm -f
# 使用管道和 xargs = -exec
# 查找 /var 下最大的十个文件
find /var -type f -ls | sort -k 7 -r -n | head
# 查找 /var/log 下大于 5GB 的文件
find /var/log/ -type f -size +5120M -exec ls -lh {} \;
# 找出今天所有文件并将它们拷贝到另一个目录
find /home/wdxtub/ -ctime 0 -print -exec cp {} /mnt/backup/{} \;
```

远程登录 ssh

```
`ssh -vvv username@ip` ssh 的 debug 模式
`ssh -i key.pem username@ip` 用 pem key 登录 ssh

```

奇技淫巧
这里是一些比较零碎的命令行技巧

```
openssl rand -hex n 产生随机的十六进制数，n 是字符数
source /path/to/filename 在当前 shell 里执行一个文件里的命令
${variable:0:5} 截取变量的前五个字符
wget -r --no-parent --reject "index.html*" http://hostname/ -P /home/user/dirs 用 wget 抓取完整的网站目录结构，存放到本地目录中
mkdir -p /home/wdxtub/{test0,test1,test2} 一次创建多个目录
dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img 测试硬盘写入速度
hdparm -Tt /dev/sda 测试硬盘读取速度
echo -n "test" | md5sum 获取文本的 md5
curl -I http://wdxtub.com 获取 HTTP 头信息
netstat -tln4 | awk '{print $4}' | cut -f2 -d: | grep -o '[0-9]*' 显示所有 tcp4 监听端口
time command 查看命令的运行时间
export 查看所有的环境变量
cmp file1 file2 文件内容对比
cat -n file 内容前面会显示行号
lsof -i:22 查看 22 端口现在运行的程序
lsof -c abc 显示 abc 进程现在打开的文件
lsof -p 12 看进程号为 12 的进程打开了哪些文件
```